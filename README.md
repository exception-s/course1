# Лабораторная работа №2
----

## Классы
**Класс** - программное описание типа данных, который описывает некоторую сущность поставленной задачи.

**Свойство класса** - поле данных класса(переменная, массив и т.д.), которое содержит значение некоторого параметра сущности.

**Метод класса** - функция, которая описывает то, как сущность выполняет некоторые действия.

**Объект** - конкретный пример класса, который имеет свои собственные конкретные значения свойств. (ссылка на класс)

Оператор new:
* Выделяет память под объект
* Создаёт объект(вызывает конструктор)
* Возвращает ссылку на созданный объект

**Конструктор** - специальный метод для инициализации объекта во время его создания с помощью оператора new.
Каждый класс в java имеет конструктор по умолчанию без параметров, который доступен, если не описано никаких других конструкторов.


**package** - папка/метод группировки классов
Через import можно сделать классы из какой-либо package доступными в своей программе.

## Инкапсуляция
----
Это скрытие свойств и внутренних методов в классе и предоставление доступа к ним через публичные (доступные другим классам) методы.

*Модификаторы доступа:*
* public - доступно всем
* private - доступно только внутри класса
* protected - доступно только внутри пакета класса и наследникам
* default - доступно только в пакете класса
* _getter и setter_  - методы, которые, соответственно, возвращают и меняют значение какого-либо поля в классе.

## Наследование
----
_Наследование_ нужно, когда у некоторого множества классов есть много общих атрибутов, общего поведения.
Мы ищем одинаковые атрибуты, методы и образуем класс-предок, от которого будет наследоваться множество наследников, использующих что-либо от предка.

Используя ключевое слово super, можно вызвать конструктор родительского класса. Уникальные характеристики наследующего класса указываем в самом наследника (инициализация доп. полей, которых уже нет в предке).


## Полиморфизм
----
Использование методов дочерних классов объектами родительского класса.
*Перегрузка функций: **(@Override)** *
* Все методы в Java могут быть перегружены (кроме методов final).
* Перегруженный в дочернем классе метод будет вызван для объекта данного класса вместо метода родительского класса.
* Если метод не был перегружен, вызовется реализация метода в родительском классе.

*Одинаковые по названию, но разные по параметрам методы в одном и том же классе - та же перегрузка, но @Overload*

## Вопрос от Письмака с лекции

_Зачем в java конструкторы с модификатором доступа private?_
1) Не нужна работа с объектами класса, используются только его static методы.
2) Классы вне метода создавать нельзя: гарантия, например, существования ровно одного объекта соответствующего класса.

## Области видимости переменных
----
Переменные доступны в том блоке кода, в котором они объявлены. Например, если переменная объявлена в начале какого-либо метода, она будет доступна внутри всего тела метода. Если переменная объявлена внутри if, к примеру, она будет доступна лишь внутри блока if. То же работает с циклами, яркий пример - переменная i, которая обычно используется внутри цикла for.
* Область видимости аргументов метода — тело метода.

### Внутри класса область видимости зависит от типа переменной:

* Статические переменные принадлежат самому классу. Они доступны без создания объекта, область их видимости содержит все методы класса — как статические, так и нет.
* Нестатические переменные класса принадлежат экземпляру класса (объекта). В их область видимости попадают нестатические методы класса.

## Ключевое слово this

Чтобы использовать переменную класса, необходимо на неё явно указать с помощью ключевого слова this.

## Модификаторы final и static
---
**final** — это модификатор, позволяющий объявлять константные поля в классе. Если у вас есть некоторое свойство проектируемого вами объекта, значение которого не будет меняться, то вы можете воспользоваться этим модификатором. Любая попытка переопределить значение поля с модификатором final приводит к выбросу исключения.

**static** - поле*(единое для всех объектов)*: существует на уровне класса, а не объекта; Для каждого класса создается только один экземпляр статической переменной (переменой класса).




 **EXPLICIT EXPLICIT EXPLICIT EXPLICIT EXPLICIT EXPLICIT EXPLICIT EXPLICIT EXPLICIT EXPLICIT EXPLICIT**
-----
_Подключение внешнего jar-файла к себе в программу сразу на гелиосе._
1) Напишите работающую программу у себя в IDE/иным любым способом.
2) Скиньте любым способом файлы программы на гелиос (покемоны .java, атаки .java, файл main (основной код)) (конечно же, лучше создать репозиторий на гитхабе
и склонировать его на гелиос - максимально просто)
3) Скиньте на гелиос сам внешний jar-файл, разберитесь и сформируйте файл MANIFEST.MF (приложу явный пример к README, первая строчка мастхев, 
вторая - про Class-Path, позже об этом, третья - класс, в котором содержится метод main - запуск всего кода, а так же обязательно перенос строки в конце)
4) Всё скинули? Прекрасно, можно работать дальше. Когда мы сформировали на гелиосе директорию с нашими файлами (не умаляя общности, назовём её lab2, это неважно)
мы должны скомпилировать наши файлы: с атаками покемонов легче, назовём директорию с атаками attacks, тогда команда

```java

javac -cp Pokemon.jar: attacks/*

```

скомпилирует все .java файлы в папке attacks.
-cp - флаг classpath, после которого идут файлы/директории, _откуда_ компилятор берёт информацию для файлов из attacks.

Pokemon.jar лежит внутри директории lab2(наравне с main и папками attacks, pokemons)
Далее папка с покемонами: 

```java

javac -cp Pokemon.jar: pokemons/name.java

```

Где name.java заменяется на имена нужных вам покемонов(поочерёдно!) сначала условно name_1, потом name_2, и так далее до name_k (до k-ого покемона).
Скомпилировали папки атак и покемонов.
Далее компилируем основной файл с main:

```java

javac -cp Pokemon.jar: main.java

```

Здесь, очевидно, main.java - файл с основным кодом(у вас он может называться по-другому, это неважно, просто смените в команде имя).

Прекрасно! Осталось всего ничего.
Нужно сформировать jar со всем нужным:

```java

jar -cfm <название>.jar MANIFEST.MF *

```

Вместо <название> вставляете всё, что душе угодно. * означает, что мы берём в jar все файлы в текущей директории(просто папки с атаками и покемонами, основной код и файл Pokemon.jar)
Всё! Осталось запустить наш файл:

```java

java -jar <название>.jar

```

Готово, можно наслаждаться результатом.
